#' Get a ranked reports
#'
#' @param date_range A two length vector of start and end Date objects
#' @param metrics Metric to send
#' @param dimensions Dimension to send
#' @param num_rows How many rows
#' @param rsid Adobe report number
#'

#' @export
#' @import assertthat httr purrr tidyr dplyr jsonlite
#'
aa_ranked_report <- function(date_range,
                              metrics,
                              dimensions,
                              top = 50,
                              metricSort = FALSE,
                              metricFilters = NULL,
                              dimensionSort = 'asc',
                              rsid = Sys.getenv("AA_RSID")){


  # set the timeframe variable
  timeframe <- make_timeframe(date_range[[1]], date_range[[2]])

  metrics_information <- list(metrics,seq_along(metrics)-1, metricSort)

  meta <- purrr::pmap(metrics_information,addmetrics)

  req_body <- structure(list(rsid = Sys.getenv("AA_RSID"),
                             globalFilters = list(list(
                               type = "dateRange",
                               dateRange = timeframe)),
                             metricContainer = list(
                               metrics = meta
                             ),
                             dimension = sprintf("variables/%s",dimensions),
                             settings = list(
                               countRepeatInstances = TRUE,
                               limit = top,
                               page = 0,
                               dimensionSort = "asc"
                             ),
                             statistics = list(
                               functions = c("col-max", "col-min")
                             ) ) )

  res <- aa_get_data("reports/ranked", body = req_body)

  res <- jsonlite::fromJSON(res)

  # Clean up and return as data frame
  res_df <- res$rows

  # If more than one metric the value list needs to be spread to individual columns
  if(length(metrics) > 1 ) {
     res_df <- res_df %>%
                  unnest(data) %>%
                  group_by(itemId,value) %>%
                  mutate(col = seq_along(data)) %>%
                  spread(key=col, value=data)
  }

  # Add column names to the dataset based on the metrics and dimensions
  colnames(res_df) <- c(paste0(dimensions,'id'),dimensions,metrics)

  res_df
}
